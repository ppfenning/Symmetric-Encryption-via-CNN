import pickle
from pathlib import Path
import numpy as np
from audio_encrypter.chaos import chaotic_cipher
import re


def __get_chaos_key(keypath: Path):
    """
    The __get_chaos_key function is used to generate a random seed for the chaos functions.
    The keypath argument is a pathlib Path object that points to where the file should be saved.
    If it does not exist, then it will create one with random values and save it there. If it does exist, then
    it will load those values from that file and return them as a dictionary.

    :param keypath: Path: Specify the path to the key file
    :return: A dictionary of the form:
    :doc-author: Trelent
    """
    if not keypath.exists():
        keypath.parent.mkdir(parents=True, exist_ok=True)
        with keypath.open('wb') as writer:
            pickle.dump(
                {
                    'henon_0': {
                        "v0": np.random.random(2),
                        "params": dict(zip(["a", "b"], np.array([1.4, 0.3], dtype=float))),
                        'primer': int(np.random.randint(100, 500, 1))
                    },
                    'ikeda_0': {
                        "v0": np.random.random(2),
                        "params": dict(zip(["mu", "beta", "gamma"], np.array([0.7, 0.4, 6], dtype=float))),
                        'primer': int(np.random.randint(100, 500, 1))
                    },
                    'lorenz_0': {
                        "v0": np.random.random(3),
                        "params": dict(zip(["sigma", "beta", "rho"], np.array([10, 8/3, 28], dtype=float))),
                        'primer': int(np.random.randint(100, 500, 1))
                    },
                    'logistic_0': {
                        "v0": np.random.random(1),
                        "params": dict(zip(["r"], np.array([4], dtype=float))),
                        'primer': int(np.random.randint(100, 500, 1))
                    },
                }
                , writer
            )
    with keypath.open('rb') as reader:
        return pickle.loads(reader.read())


def __transform(data, byte_len):
    """
    The __transform function takes in a numpy array of data and the dtype of the data.
    It then returns an array with values that are within the range of 0 to 2^n-2, where n is
    the number of bits in each value. This is accomplished by taking absolute values, multiplying
    by 10^10 (to ensure all numbers have at least 10 decimal places), rounding down to nearest integer,
    and then modding by 2^n-2.

    :param data: Store the data that is to be transformed
    :param dtype: Specify the data type of the output array
    :return: A numpy array of the input data in a specified bit format
    :doc-author: Trelent
    """
    return np.mod(np.floor(np.abs(data) * 10 ** 10), 2**byte_len)


def __xor(columns, str_type):
    return np.bitwise_xor.reduce(columns.astype(f"u{str_type}")).astype(str_type)


def __chaotic_ciphertext(audio, chaos_key):
    """
    The __chaotic_ciphertext function takes an audio array and a chaos key,
    and returns the chaotic ciphertext of the audio.
    The chaotic ciphertext is generated by XORing each sample with its corresponding value in a chaotic sequence.
    The length of the sequence must be equal to that of the audio array.
    
    :param audio: Store the audio file that will be encrypted
    :param chaos_key: Pass the parameters of the chaotic function
    :return: A numpy array of the same type as
    :doc-author: Trelent
    """
    str_type = audio.dtype.name
    byte_len = int(re.findall(r'\d+', str_type)[0])
    cipher = __xor(__transform(chaotic_cipher(audio.shape[0], **chaos_key), byte_len).T, str_type)
    return np.array(list(map(lambda channel: __xor(np.array([channel, cipher]), str_type), audio.T))).T


def chaotic_ciphertext(audio, keypath):
    """
    The chaotic_ciphertext function takes an audio file and a keypath as input,
    and returns the chaotic ciphertext of the audio file. The chaotic ciphertext is
    the result of applying a chaos function to each sample in the audio file. The
    chaos function used is determined by the keypath.
    
    :param audio: Store the audio data
    :param keypath: Specify the path to the chaos key file
    :return: A numpy array of the chaotic ciphertext
    :doc-author: Trelent
    """
    return __chaotic_ciphertext(audio, __get_chaos_key(keypath))




