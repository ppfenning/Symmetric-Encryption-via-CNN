import pickle
import re
from pathlib import Path
import numpy as np
from .chaos import (
    sim_chaotic_attractor,
    henon,
    ikeda,
    lorenz,
    logistic
)


def __transform(data, dtype):
    """
    The __transform function takes in a numpy array of data and the dtype of the data.
    It then returns an array with values that are within the range of 0 to 2^n-2, where n is
    the number of bits in each value. This is accomplished by taking absolute values, multiplying
    by 10^10 (to ensure all numbers have at least 10 decimal places), rounding down to nearest integer,
    and then modding by 2^n-2.

    :param data: Store the data that is to be transformed
    :param dtype: Specify the data type of the output array
    :return: A numpy array of the input data in a specified bit format
    :doc-author: Trelent
    """
    return np.mod(np.floor(np.abs(data) * 10 ** 10), 2**int(re.findall(r'\d+', dtype)[0]))


def __get_chaos_key(keypath: Path):
    """
    The __get_chaos_key function is used to generate a random seed for the chaos functions.
    The keypath argument is a pathlib Path object that points to where the file should be saved.
    If it does not exist, then it will create one with random values and save it there. If it does exist, then
    it will load those values from that file and return them as a dictionary.

    :param keypath: Path: Specify the path to the key file
    :return: A dictionary of the form:
    :doc-author: Trelent
    """
    if not keypath.exists():
        keypath.parent.mkdir(parents=True, exist_ok=True)
        with keypath.open('wb') as writer:
            pickle.dump(
                {
                    'primer': int(np.random.randint(1000, 10000, 1)),
                    'henon_0': np.random.random(2),
                    'ikeda_0': np.random.random(2),
                    'lorenz_0': np.random.random(3),
                    'logistic_0': np.random.random(1),
                }
                , writer
            )
    with keypath.open('rb') as reader:
        return pickle.loads(reader.read())


def __chaotic_cipher(audio_len, str_type, *, primer, henon_0, ikeda_0, lorenz_0, logistic_0, ):
    """
    The __chaotic_cipher function is a helper function that takes in the length of an audio file,
    the type of string to return (either 'bytes' or 'str'), and four initial conditions for chaotic attractors.
    The function then simulates each chaotic attractor with the given initial conditions, concatenates them together,
    and transforms them into either bytes or a string. The first primer number of elements are thrown away before 
    returning the transformed array.
    
    :param audio_len: Determine how long the audio file is
    :param str_type: Determine the type of string to return
    :param *: Indicate that the following parameters are keyword only
    :param primer: Throw away the first few values of the chaotic attractors
    :param henon_0: Set the initial conditions of the henon attractor
    :param ikeda_0: Set the initial conditions for the ikeda attractor
    :param lorenz_0: Set the initial conditions for the lorenz attractor
    :param logistic_0: Initialize the logistic map
    :param : Determine the length of the audio file
    :return: A numpy array of the chaotic cipher
    :doc-author: Trelent
    """
    file_len = audio_len + primer
    return __transform(
        np.concatenate((
            sim_chaotic_attractor(henon, file_len, henon_0),
            sim_chaotic_attractor(ikeda, file_len, ikeda_0),
            sim_chaotic_attractor(lorenz, file_len, lorenz_0),
            sim_chaotic_attractor(logistic, file_len, logistic_0)
        ), axis=1)
        , str_type
    )[primer:]


def __chaotic_ciphertext(audio, chaos_key):
    """
    The __chaotic_ciphertext function takes an audio array and a chaos key,
    and returns the chaotic ciphertext of the audio.
    The chaotic ciphertext is generated by XORing each sample with its corresponding value in a chaotic sequence.
    The length of the sequence must be equal to that of the audio array.
    
    :param audio: Store the audio file that will be encrypted
    :param chaos_key: Pass the parameters of the chaotic function
    :return: A numpy array of the same type as
    :doc-author: Trelent
    """
    str_type = audio.dtype.name
    return np.bitwise_xor.reduce(
        np.append(
            audio[:, np.newaxis],
            __chaotic_cipher(audio.size, str_type, **chaos_key),
            axis=1
        ).astype(f'u{str_type}'),
        axis=1
    ).astype(str_type)


def chaotic_ciphertext(audio, keypath):
    """
    The chaotic_ciphertext function takes an audio file and a keypath as input,
    and returns the chaotic ciphertext of the audio file. The chaotic ciphertext is
    the result of applying a chaos function to each sample in the audio file. The
    chaos function used is determined by the keypath.
    
    :param audio: Store the audio data
    :param keypath: Specify the path to the chaos key file
    :return: A numpy array of the chaotic ciphertext
    :doc-author: Trelent
    """
    return __chaotic_ciphertext(audio, __get_chaos_key(keypath))
